# üß© **C Complexity Analyzer**

This tool was developed as part of a research project focused on analyzing the **cognitive and structural complexity** of C programming exercises.  
It was originally created to address the lack of small, open-source, and easily adaptable tools for static code analysis in C using **abstract syntax tree**.

The current version performs **static analysis** to extract metrics derived from the **Halstead complexity model**, **cyclomatic complexity**, and **line-based metrics**, all based on the **Abstract Syntax Tree (AST)** generated by [`pycparser`](https://github.com/eliben/pycparser).

---

## üß† **Overview**

The **C Complexity Analyzer** aims to support studies on programming learning by quantifying characteristics of source code that relate to cognitive effort and software complexity.  
The tool processes C source files, parses them into an **AST**, and traverses its nodes to extract relevant information about the program‚Äôs structure, flow, and operators/operands.

It can also handle **incomplete or syntactically invalid code**, which is particularly useful in educational environments where students' submissions might not always compile successfully.

---

## ‚öôÔ∏è **How the Analysis Works**

### 1. **Preprocessing**
C source files are first **precompiled** using GCC to generate an intermediate `.i` file.  
This stage expands macros and resolves preprocessor directives, making the source ready for AST parsing.

A `Makefile` is provided to automate this step:

```
make preprocess DIR=Examples/
```
This process uses the fake headers provided by pycparser (fake_libc_include/) to ensure that standard library references are correctly handled during preprocessing.

The fake headers simulate standard C headers ‚Äî they don‚Äôt provide implementation, only structure definitions ‚Äî allowing the parser to correctly process source files that include libraries such as stdio.h or stdlib.h.

2. AST Generation

Once preprocessed, the file is parsed using pycparser, which constructs an Abstract Syntax Tree representing the syntactic structure of the program.

Each node in this tree corresponds to a language construct ‚Äî such as expressions, declarations, or control structures ‚Äî and is visited by specific methods (visit_NodeType) in the tool‚Äôs core class.
These visitor methods are responsible for identifying operators, operands, and control structures, which are then used to compute software metrics.
3. Metric Extraction

From the AST traversal, the following metrics are computed:

    Halstead Metrics ‚Äî Derived from operator and operand occurrences:

        Distinct operators (n1)

        Distinct operands (n2)

        Total operators (N1)

        Total operands (N2)

        Vocabulary, Length, Volume, Difficulty, Effort, Time, and Estimated Bugs

    Cyclomatic Complexity (McCabe) ‚Äî Calculated per function and for the entire program.

    Lines of Code ‚Äî Total and effective (non-empty, non-comment).

Each metric is stored internally and displayed in formatted tables using the rich

library.

## üå≥ AST-Based Computation

All metrics, except line counting, are derived from the AST representation of the program.
Each syntactic construct (e.g., If, For, Assignment, FuncCall) triggers a specific method that registers operators and operands based on their occurrence in the tree.

This AST-driven approach ensures:

    Structural and semantic accuracy in identifying complexity indicators;

    Independence from specific formatting or code style;

    Extensibility ‚Äî new metrics can be implemented by adding new visitor methods for node types.

## üìà Example Outputs
üîπ Complexity Summary
<!-- TODO: Insert new image link here -->

output
üîπ Functions Cyclomatic Complexity
<!-- TODO: Insert new image link here -->

functions_output
üîπ Operators
<!-- TODO: Insert new image link here -->

operators_output
üîπ Operands
<!-- TODO: Insert new image link here -->

operands_output
## üß™ **Research Context**

This tool was developed within a broader research initiative that investigates **static analysis of C programs** with a focus on **cognitive and structural complexity metrics**.  
Its development serves both as an experimental platform and as a methodological contribution to the field of program comprehension and metric-based assessment.

The project aims to:

- **Propose a refined method for Halstead operator and operand counting**, contextualized according to the syntactic and semantic roles of code elements within the Abstract Syntax Tree (AST);  
- Enable **systematic evaluation of programming exercises**, allowing complexity to be measured consistently across diverse code solutions;  
- **Bridge theoretical models and educational practice**, providing data to support cognitive studies on programming learning;  
- Serve as a **framework for experimental research** in static code analysis and metric-based software evaluation;  
- Contribute to **future tools for educational analytics**, such as automatic exercise recommendation, difficulty estimation, and adaptive assessments.

üîß Planned Updates

    Refactor metric computation for clearer modular separation.

    Extend support for custom or missing fake headers (e.g., cs50.h, CRpaic.h).

    Integrate cognitive complexity estimation models.

üìú License

This project is open-source and available for research and educational purposes.
